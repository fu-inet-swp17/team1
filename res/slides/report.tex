\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}
%\usepackage{a4wide}
\usepackage[onehalfspacing]{setspace}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{csquotes}
\usepackage{listings}
\usepackage{siunitx}
\usepackage{wrapfig}
\usepackage{caption}
%% Bibtex
\usepackage[backend=biber,style=authoryear,autocite=footnote]{biblatex}

\title{%
  Reaktionsspiel mit Bandgeräten \\
  \large Softwareprojekt: Internetkommunikation}
\author{Steve Dierker, Patrick Hjort, Semjon Kerner}

\begin{document}
\maketitle

\section{Einführung}
  \label{sec:intro}
  Das Ziel dieses Projektes ist es, die \textit{PDP11} im Foyer des
  Informatikinstituts der FU Berlin wieder mit Leben zu f"ullen und sie nicht
  nur als leere H"ulle zu pr"asentieren. Uns ist es dabei besonders wichtig
  unsere Mitstudierende zum eigenst"andigen entdecken der \textit{PDP11} zu
  animieren.  Daher haben wir die bestehende Bandlaufwerke mit einem modernen
  Mikrocontroller ausgestattet, der von nun an die Ansteuerung "ubernimmt.
  Dieser Mikrocontroller, die vorhandene Bandlaufwerke, ein paar weitere LEDs
  und ein LCD erm"oglichen es uns die \textit{PDP11} in Arcade "ahnliche
  Spieleautomaten umzuwandeln.\\
  Ziel dieses Projektes ist es, die Hardware fertigzustellen und ein
  Beispielspiel zu implementieren, das es zwei Spieler\_innen erm"oglicht sich
  in ihrer Reaktionszeit zu messen.\\
  Als erstes werden wir einen "Uberblick "uber die verwendete Hardware geben
  und auf die Besonderheiten und Probleme bei der Ansteuerung dieser eingehen.
  Danach gehen wir auf die Software selbst und die Kommunikation unterhalb der
  Knoten ein. Abschliessend ziehen wir ein vergleichendes Resume zwischen der
  Planung und dem Erfolg des Projekts und bieten einen Ausblick auf
  weiteref"uhrende Ideen.

\section{Hardware}
  \label{sec:hardware}
  \subsection{vorhandene Hardware}
    \label{sec:hardware_existing}
    Als Basis f"ur unser Projekt dient die im Foyer stehende und leider nicht
    mehr funktionst"uchtige \textit{PDP11}. Im besonderen haben wir uns f"ur
    die zwei Bandlaufwerke der \textit{PDP11} interessiert, da sie jeweils neun
    Taster und zwei einzeln ansteuerbare Motoren bieten. Die Motoren k"onnen im
    und gegen den Uhrzeigersinn drehen und bieten durch die
    Ger"auschentwicklung sowie ihre Bewegung einen guten Ausl"oser f"ur unser
    Reaktionsspiel.\\
    Von den neun Tastern sind zwar alle mit unserem Mikrocontroller verbunden
    und auch per Software ansteuerbar, allerdings sind derzeit nur die
    ersten drei Taster in Verwendung.

  \subsection{zus"atzliche Hardware}
    \label{sec:hardware_additional}
    F"ur dieses Projekt wurde uns ein \textit{SAMR21 Xpro} zur Verf"ugung
    gestellt. Der \textit{SAMR21 Xpro} ist ein Evaluationsboard f"ur den
    \textit{ATSAMR21G18A}. Das Board bietet integrierte Funkunterst"utzung zur
    Kommunikation und durch den \textit{Cortex-M0+} auch ausreichend Leistung um
    unser Projekt umzusetzen. Im Zuge der Softwareentwicklung sind wir nicht
    an die Leistungsgrenzen des Chips gesto"sen, allerdings bietet er nicht
    gen"ugend I/O-Pins zur Ansteuerung der gesamten Peripherie.\\
    \begin{wrapfigure}{r}{0.5\textwidth}
      \centering
      \label{figure:Hardwareplattform}
      \includegraphics[scale=0.05]{Platine.jpg}
      \captionof{figure}{Mikrocontroller, Multiplexer und H-Br"ucke}
    \end{wrapfigure}
    In Ermangelung ausreichender I/O-Pins haben wir uns dazu entschieden die Taster
    "uber den \textit{S74LS151} anzusteuern. Der \textit{S74LS151} ist ein 8Bit
    Multiplexer und erm"oglicht es uns alle Taster anzusteuern, allerdings kann
    nur ein Taster gleichzeitig mit einem Interrupt belegt werden.\\
    Zur Beleuchtung der Bandlaufwerke haben wir RGB-LED-Streifen verbaut. Diese
    LED-Streifen basieren auf dem \textit{WS2811}, der jeweils eine LED steuern
    und bis zu 1024mal in Reihe geschaltet werden kann um komplette
    Animationen zu steuern. Die existierenden Gl"uhlampen der Taster wollten
    wir ebenfalls durch LED's ersetzen die auf dem \textit{WS2811} basieren,
    allerdings gab es hier Lieferprobleme.\\
    \begin{wrapfigure}{r}{0.5\textwidth}
      \centering
      \label{figure:Bandlaufwerke}
      \includegraphics[scale=0.075]{Frontansicht.jpg}
      \captionof{figure}{Frontansicht der Bandlaufwerke}
    \end{wrapfigure}
    Zur Ansteuerung der Bandlaufwerkmotoren verwenden wir die doppel H-Br"ucke
    \textit{L298-H}. Diese ben"otigt als einziges Modul eine 12V
    Versorgungsspannung.\\
    F"ur zuk"unftige Men"uf"uhrung, Eingabe der Nicknames und weiteres
    visuelles Feedback haben wir ein 128x64 Pixel LCD des Typs
    \textit{DOGL128B-6} verbaut. Dieses Display ist ein Set aus Display und
    Controller und kann einfach "uber das SPI Protokoll verwendet werden. Um
    Kosten an der Hardware zu sparen haben wir uns dazu entschieden nicht
    vorgefertigte Backlight dazu zukaufen, sondern jeweils zwei \textit{WS2811}
    RGB-LEDs f"ur die Hintergrundbeleuchtung zu verwenden.\\
    Unsere verbaute Hardware brauch eine \( 3,3V \), \( 5V \) und \( 12V \)
    Spannungsversorgung und anstatt selber ein Netzteil zu bauen oder zu kaufen
    haben wir ein ATX-Netzteil aus Restbest"anden f"ur beide Bandlaufwerke
    benutzt.

  \subsection{Treiber}
    \label{sec:hardware_driver}
    Nach der Entwicklung der Hardwareplattform haben wir f"ur jede Peripherie
    einen Teiber entwickelt, da diese noch nicht von RIOT selbst unterstützt
    wurden. Jeder Treiber ist entsprechend den von RIOT angebotenen
    Beispieltreibern implementiert. Die Treiberimplementierung war für alle
    Peripheriegeräte außer dem WS2811 unkompliziert. Der WS2811 bietet einen
    digitalen Eingang zum Empfang von Farbinformationen und einen digitalen
    Ausgang zum Senden von Farbinformationen an den nächsten WS2811 in Reihe.
    Zum Schluss steuert jede WS2811 eine LED und bis zu 1024 WS2811 können
    miteinander verkettet werden, um ganze LED-Arrays zu steuern. Da der WS2811
    nur ein OneWire-Protokoll und keine zusätzliche Taktung anbietet, benötigt
    er für die Unterscheidung zwischen 0 und 1 in seinem Protokoll harte
    Timings. Für unser Projekt haben wir zwei verschiedene WS2811 LED-Sets
    gekauft. Das erste ist ein bereits montierter LED-Streifen, der mit unserem
    Treiber tadellos funktioniert und das zweite ist ein Set von separaten
    Chips und LEDs, die selbst zusammenzubauen sind. Das zweite Set weigerte
    sich, mit unserem Treiber zu arbeiten und nach mehrtägigem Debugging
    stellte sich heraus, dass der Controller eine gemeinsame Annode benötigt,
    aber die LEDs, die wir erhalten haben, boten eine gemeinsame Kathode.
    Leider war der Internetversand, bei dem wir die LEDs gekauft haben, nicht
    in der Lage, die richtigen LEDs rechtzeitig zur Verfügung
    zu stellen, um das Projekt komplett abzuschließen.

\section{Retro11}
  \label{sec:retro11}
  Retro11 ist die C-Basierte RIOT-Anwendung, die auf dem \textit{SAMR21 XPro}
  l"auft. Neben der Kontrolle über die vorhandene Hardware wird diese
  Anwendung mit einem einfachen Spiel ausgeliefert, um in der Reaktionszeit zu
  konkurrieren, welche weiter unten erklärt wird. Um Spieler gegeneinander
  antreten zu lassen, ist es notwendig, zwischen den Spielplattformen zu
  kommunizieren. Dazu implementiert die Anwendung einen COAP-Client und
  -Server.\\

  \subsection{Anwendungsdesign}
    \label{sec:retro11_design}
    Was das Anwendungsdesign selbst betrifft, initialisieren wir zunächst alle
    benötigten Treiber und starten dann vier Threads, um die verschiedenen Aspekte
    unserer Anwendung zu steuern. Der erste Thread ist der MotorController, der auf
    Meldungen zum Starten oder Stoppen des Motors wartet. Da wir die Motoren für
    eine bestimmte Zeit benötigen, kann man auch ein Timeout übergeben, nach dem
    der Motor gestoppt werden soll. Der zweite Thread ist der CoapServer, der die
    Kommunikation zwischen den beiden Knoten handhabt und die Endergebnisse auch
    an das RasperryPi von team2 weiterleitet, um eine webfähige Highscore zu
    erstellen. Der dritte Thread ist das Spiel selbst, das die Kontrolle über alle
    Peripheriegeräte übernimmt und mit dem CoapServer über eine
    Shared-State-Variable kommuniziert. Das Spiel steuert die Benutzereingaben und
    -ausgaben und bietet ein Arcade-ähnliches Spielerlebnis. Der vierte und letzte
    Thread dient zu Debugging-Zwecken und führt einfach eine Shell mit
    benutzerdefinierten Befehlen für Hardware-Diagnose und andere
    Debuggingoperationen aus. Er ist nur zugänglich, wenn ein Computer an den
    USB-Port des SAMR21 Xpro angeschlossen wird.\\

  \subsection{Reaktionsspiel}
    \label{sec:retro11_game}
    Für dieses Spiel haben Sie mindestens zwei Spieler, die beide vor einem der
    PDP11 an der FU Berlin stehen. Zuerst werden sie aufgefordert, dort einen
    Nickname einzugeben, der an den zentralen Server geschickt wird, um später die
    Reaktionszeit zu speichern und einen Highscore anzuzeigen. Das Spiel startet
    die Bandlaufwerkmotoren der beiden Knoten und sobald sie gestoppt werden, wird
    der Spieler aufgefordert, so schnell wie möglich zu reagieren und einen Knopf
    zu drücken. Die Zeit zwischen dem Anhalten des Motors und der Reaktion des
    Spielers ist die Reaktionszeit, die dann zur Ermittlung des Siegers
    herangezogen wird. Den Highscore können Sie in der Webapplikation von team2 des
    diesjährigen Softwareprojekts nachschlagen.\\

  \subsection{Netzwerkkommunikation}
    \label{sec:net}
    Die Kommunikation zwischen den Plattformen erfolgt über das RESTful Constrained
    Application Protocol, CoAP, das Nachrichten über UDP und IPv6 sendet, wie in
    Abbildung \ref{fig:seq_diagram} . Ein Mikrocontroller führt eine
    Client-Applictation aus, die das Spiel steuert. Die benötigten Informationen
    werden von einer Server-Anwendung bereitgestellt, die auf jedem Mikrocontroller
    ausgeführt wird. Abhängig vom Spielstatus fragt der Client die Ressource mit
    den erforderlichen Informationen beider Server mit einer Get-Methode ab, bis
    die Server die Informationen bereitstellen, um zur nächsten Stufe überzugehen.
    Im ersten Zustand fordert der Client die Nicknamen des Spielers an, fordert
    dann das eigentliche Reaktionsspiel auf, im zweiten Zustand zu starten, fordert
    die Reaktionszeit im dritten Zustand an und fordert jede Maschine auf, sich
    anzeigen zu lassen, ob sie im letzten Zustand gewonnen oder verloren hat.
    Zusätzlich verfügen beide Server über eine Ressource, die auf Wunsch von team2
    Highscore-Informationen im SenML-Format bereitstellt.
    \begin{figure}[h]
      \centering
      \includegraphics[scale=0.1]{team1_kommunikation.png}
      \caption{\label{fig:seq_diagram}Sequenzdiagramm der Anwendung}
    \end{figure}

\section{Stand der Umsetzung}
  \label{sec:status}
  \subsection{Probleme}
    \begin{itemize}
      \item LEDs von Buttons fehlen
      \item Kommunikation Raspi
        \begin{itemize}
          \item konsistente API zu netzwerkcode, keine trennung von businnes zu netzwerk
          \item netwzwerk unreliable
          \item integration in team2 ungen"ugend
        \end{itemize}
      \item LCD Kontrast, Backlight, Wackelkontakt
      \item Kein dokumentiertes Board layout
    \end{itemize}
  \subsection{Rückblick auf Zeitplan}
    \begin{itemize}
      \item Zeitplan nicht eingehalten, warum?
      \item Hardware hat mehr Zeit gekostet als erwartet
      \item Probleme mit Netzwerkkommunikation
      \item Gar nicht nach Magnetbändern gesucht
      \item Spiel runterschreiben ging am Ende dann schnell, erahrungswerte haben gefehlt
      \item mangelhafte schnittstellen definition zwischen Application und Netzwerk stack
      \item trotz regelmaessiger persoenlicher treffen keine stand-up-meeting, somit mangelndes wissen "uber probleme und fortschritte der gruppenmitglieder
      \item Entwurf Poster war schnell aber nicht so früh wie geplant
    \end{itemize}

\section{Weiterführende Arbeit}
  \label{sec:further}
  Zuerst gilt es die bis jetzt nicht gelieferten RGB-LED's wie in Abschnitt
  \ref{sec:hardware_additional} beschrieben in die Taster einzubauen. Bis
  jetzt werden die zu dr"uckenden Taster nicht visuel hervorgehoben, sodass
  f"ur Nutzer nicht offensichtlich ist welcher Taster welche Funktionsbelegung
  that.\\
  Zur weiteren Versch"onerung der Bandlaufwerke sollten die fehlenden
  Tasterfront gedruckt werden. Ein druckfertiges 3D-Modell ist schon im
  Repository vorhanden. Im Zuge dessen sollten auch die Motoren gereinigt
  werden, da sie sich zur Zeit erst bei einer verh"altnism"a"sig hohen
  Anlaufspannung in Bewegung setzen. Dies w"urde Lautst"arkeentwicklung und
  Stromverbrauch optimieren.\\
  Im Bezug auf \textit{Retro11} sollte als erstes ein Framework entwickelt
  werden in dem weitere Spiele implementiert werden k"onnen.
  Eine M"oglichkeit besteht darin einen Lua-Interpreter in \textit{Retro11}
  einzubetten. znteressierte Studierende sind dann in der Lage Spiele in einer
  Hochsprache gegen eine konsistente API zu entwickeln und m"ussen nicht
  notwendigerweise mit RIOT vertraut sein. Insbesondere f"ur Programmieranf"anger
  bietet das einen niederschwelligen Einstieg in eingebettete Systeme.\\
  Da regelm"a"sige manuelle Updates der vorhandenen Spiele auf der
  Platform ein zeitintensives Unterfangen ist, sollte als n"achstes "uber eine
  Over-the-Air Updatefunktion f"ur die komplette Applikation oder zumindest
  f"ur die Spielebibliothek nachgedacht werden. F"ur RIOT selbst ist gerade ein
  OTA-Update in Entwicklung das nach Fertigstellung genutzt werden kann.\\\\

\end{document}
